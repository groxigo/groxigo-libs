/**
 * Token Documentation Generator
 *
 * Generates a comprehensive Markdown catalog of all design tokens
 * during the build step. Output: dist/docs/token-catalog.md
 */

import { tokens } from '../tokens';
import { createTheme } from '../theme';
import {
  FLUID_FONT_SIZES,
  FLUID_SPACINGS,
  FLUID_RADII,
  FLUID_BUTTON_HEIGHTS,
  FLUID_BUTTON_PADDING_X,
  FLUID_BUTTON_PADDING_Y,
  FLUID_INPUT_HEIGHTS,
} from './css';

const theme = createTheme();

/**
 * Generate the complete token catalog markdown.
 */
export function generateDocs(): string {
  const sections: string[] = [];

  sections.push('# Groxigo Design Token Catalog');
  sections.push('');
  sections.push('> Auto-generated by `@groxigo/tokens` build. Do not edit directly.');
  sections.push('');

  sections.push(generatePrimitivesSection());
  sections.push(generateSemanticSection());
  sections.push(generateComponentSection());
  sections.push(generateSpacingSection());
  sections.push(generateTypographySection());
  sections.push(generateRadiusSection());
  sections.push(generateAnimationSection());

  return sections.join('\n');
}

// ============================================
// SECTION GENERATORS
// ============================================

function generatePrimitivesSection(): string {
  const lines: string[] = [];
  lines.push('## Primitives');
  lines.push('');

  const colorFamilies = ['gray', 'blue', 'green', 'red', 'yellow', 'orange', 'purple', 'cyan', 'pink', 'indigo', 'teal'] as const;

  lines.push('### Absolute Colors');
  lines.push('');
  lines.push('| Token | CSS Variable | Value |');
  lines.push('|---|---|---|');
  lines.push(`| white | \`--color-white\` | \`${tokens.colors.primitives.white}\` |`);
  lines.push(`| black | \`--color-black\` | \`${tokens.colors.primitives.black}\` |`);
  lines.push(`| transparent | \`--color-transparent\` | \`${tokens.colors.primitives.transparent}\` |`);
  lines.push('');

  for (const family of colorFamilies) {
    const label = family.charAt(0).toUpperCase() + family.slice(1);
    lines.push(`### ${label}`);
    lines.push('');
    lines.push('| Shade | CSS Variable | Hex |');
    lines.push('|---|---|---|');
    const colorFamily = tokens.colors.primitives[family];
    for (const [shade, value] of Object.entries(colorFamily)) {
      lines.push(`| ${shade} | \`--color-${family}-${shade}\` | \`${value}\` |`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

function generateSemanticSection(): string {
  const lines: string[] = [];
  const light = theme.light.semantic;
  const dark = theme.dark.semantic;

  lines.push('## Semantic Tokens');
  lines.push('');
  lines.push('| Token | CSS Variable | Light | Dark |');
  lines.push('|---|---|---|---|');

  // Surface
  emitSemanticGroup(lines, 'Surface', 'surface', light.surface as unknown as Record<string, unknown>, dark.surface as unknown as Record<string, unknown>);
  emitSemanticGroup(lines, 'Text', 'text', light.text as unknown as Record<string, unknown>, dark.text as unknown as Record<string, unknown>);
  emitSemanticGroup(lines, 'Border', 'border', light.border as unknown as Record<string, unknown>, dark.border as unknown as Record<string, unknown>);

  // Brand
  for (const brandType of ['primary', 'secondary', 'accent'] as const) {
    const lightBrand = light.brand[brandType] as unknown as Record<string, string>;
    const darkBrand = dark.brand[brandType] as unknown as Record<string, string>;
    for (const [key, lightVal] of Object.entries(lightBrand)) {
      const cssVar = `--brand-${brandType}${key === 'default' ? '' : `-${key}`}`;
      lines.push(`| brand.${brandType}.${key} | \`${cssVar}\` | \`${lightVal}\` | \`${darkBrand[key]}\` |`);
    }
  }

  // Status
  for (const status of ['success', 'warning', 'error', 'info'] as const) {
    const lightStatus = light.status[status] as unknown as Record<string, string>;
    const darkStatus = dark.status[status] as unknown as Record<string, string>;
    for (const [key, lightVal] of Object.entries(lightStatus)) {
      const cssVar = `--status-${status}${key === 'default' ? '' : `-${key}`}`;
      lines.push(`| status.${status}.${key} | \`${cssVar}\` | \`${lightVal}\` | \`${darkStatus[key]}\` |`);
    }
  }

  // Interactive
  emitSemanticGroup(lines, 'Interactive', 'interactive', light.interactive as unknown as Record<string, unknown>, dark.interactive as unknown as Record<string, unknown>);

  // Overlay
  emitSemanticGroup(lines, 'Overlay', 'overlay', light.overlay as unknown as Record<string, unknown>, dark.overlay as unknown as Record<string, unknown>);

  // Glass
  for (const sub of ['surface', 'border'] as const) {
    const lightGlass = light.glass[sub] as unknown as Record<string, string>;
    const darkGlass = dark.glass[sub] as unknown as Record<string, string>;
    for (const [key, lightVal] of Object.entries(lightGlass)) {
      const cssVar = `--glass-${sub}-${key}`;
      lines.push(`| glass.${sub}.${key} | \`${cssVar}\` | \`${lightVal}\` | \`${darkGlass[key]}\` |`);
    }
  }

  lines.push('');
  return lines.join('\n');
}

function emitSemanticGroup(
  lines: string[],
  _label: string,
  prefix: string,
  light: Record<string, unknown>,
  dark: Record<string, unknown>
): void {
  for (const [key, lightVal] of Object.entries(light)) {
    if (typeof lightVal === 'string') {
      const cssVar = `--${prefix}-${key}`;
      lines.push(`| ${prefix}.${key} | \`${cssVar}\` | \`${lightVal}\` | \`${dark[key]}\` |`);
    }
  }
}

function generateComponentSection(): string {
  const lines: string[] = [];
  const light = theme.light.components;
  const dark = theme.dark.components;

  lines.push('## Component Tokens');
  lines.push('');
  lines.push('| Component.Token | CSS Variable | Light | Dark |');
  lines.push('|---|---|---|---|');

  function emitComponent(
    prefix: string,
    cssPrefix: string,
    lightObj: Record<string, unknown>,
    darkObj: Record<string, unknown>
  ): void {
    for (const [key, val] of Object.entries(lightObj)) {
      if (typeof val === 'object' && val !== null) {
        // Nested (e.g., button.primary, badge.success)
        const darkSub = (darkObj[key] || {}) as Record<string, string>;
        for (const [subKey, subVal] of Object.entries(val as Record<string, string>)) {
          const cssVar = `--${cssPrefix}-${key}-${camelToKebab(subKey)}`;
          lines.push(`| ${prefix}.${key}.${subKey} | \`${cssVar}\` | \`${subVal}\` | \`${darkSub[subKey] || '—'}\` |`);
        }
      } else if (typeof val === 'string') {
        const cssVar = `--${cssPrefix}-${camelToKebab(key)}`;
        const darkVal = darkObj[key];
        lines.push(`| ${prefix}.${key} | \`${cssVar}\` | \`${val}\` | \`${darkVal || '—'}\` |`);
      }
    }
  }

  emitComponent('button', 'button', light.button as unknown as Record<string, unknown>, dark.button as unknown as Record<string, unknown>);
  emitComponent('input', 'input', light.input as unknown as Record<string, unknown>, dark.input as unknown as Record<string, unknown>);
  emitComponent('card', 'card', light.card as unknown as Record<string, unknown>, dark.card as unknown as Record<string, unknown>);
  emitComponent('badge', 'badge', light.badge as unknown as Record<string, unknown>, dark.badge as unknown as Record<string, unknown>);
  emitComponent('modal', 'modal', light.modal as unknown as Record<string, unknown>, dark.modal as unknown as Record<string, unknown>);
  emitComponent('nav', 'nav', light.nav as unknown as Record<string, unknown>, dark.nav as unknown as Record<string, unknown>);
  emitComponent('tab', 'tab', light.tab as unknown as Record<string, unknown>, dark.tab as unknown as Record<string, unknown>);
  emitComponent('toggle', 'toggle', light.toggle as unknown as Record<string, unknown>, dark.toggle as unknown as Record<string, unknown>);
  emitComponent('progress', 'progress', light.progress as unknown as Record<string, unknown>, dark.progress as unknown as Record<string, unknown>);
  emitComponent('alert', 'alert', light.alert as unknown as Record<string, unknown>, dark.alert as unknown as Record<string, unknown>);
  emitComponent('glass', 'glass', light.glass as unknown as Record<string, unknown>, dark.glass as unknown as Record<string, unknown>);

  lines.push('');
  return lines.join('\n');
}

function generateSpacingSection(): string {
  const lines: string[] = [];
  lines.push('## Spacing');
  lines.push('');
  lines.push('| Scale Key | CSS Variable | Base (px) | Fluid Range |');
  lines.push('|---|---|---|---|');

  for (const [key, value] of Object.entries(tokens.spacing)) {
    const fluid = FLUID_SPACINGS[key];
    const range = fluid ? `${fluid[0]}px → ${fluid[1]}px` : 'Fixed';
    lines.push(`| ${key} | \`--spacing-${key}\` | ${value}px | ${range} |`);
  }

  lines.push('');
  return lines.join('\n');
}

function generateTypographySection(): string {
  const lines: string[] = [];
  lines.push('## Typography');
  lines.push('');

  // Font sizes
  lines.push('### Font Sizes');
  lines.push('');
  lines.push('| Size | CSS Variable | Base (px) | Fluid Range |');
  lines.push('|---|---|---|---|');

  for (const [key, value] of Object.entries(tokens.typography.fontSize)) {
    const fluid = FLUID_FONT_SIZES[key];
    const range = fluid && fluid[0] !== fluid[1]
      ? `${fluid[0]}px → ${fluid[1]}px`
      : 'Fixed';
    lines.push(`| ${key} | \`--font-size-${key}\` | ${value}px | ${range} |`);
  }
  lines.push('');

  // Font weights
  lines.push('### Font Weights');
  lines.push('');
  lines.push('| Weight | CSS Variable | Value |');
  lines.push('|---|---|---|');
  for (const [key, value] of Object.entries(tokens.typography.fontWeight)) {
    lines.push(`| ${key} | \`--font-weight-${key}\` | ${value} |`);
  }
  lines.push('');

  // Line heights
  lines.push('### Line Heights');
  lines.push('');
  lines.push('| Name | CSS Variable | Value |');
  lines.push('|---|---|---|');
  for (const [key, value] of Object.entries(tokens.typography.lineHeight)) {
    lines.push(`| ${key} | \`--line-height-${key}\` | ${value} |`);
  }
  lines.push('');

  // Button heights
  lines.push('### Fluid Button Heights');
  lines.push('');
  lines.push('| Size | CSS Variable | Min | Max |');
  lines.push('|---|---|---|---|');
  for (const [size, [min, max]] of Object.entries(FLUID_BUTTON_HEIGHTS)) {
    lines.push(`| ${size} | \`--button-${size}-height\` | ${min}px | ${max}px |`);
  }
  lines.push('');

  // Button padding
  lines.push('### Fluid Button Padding');
  lines.push('');
  lines.push('| Size | Padding X | Padding Y |');
  lines.push('|---|---|---|');
  for (const size of Object.keys(FLUID_BUTTON_PADDING_X)) {
    const px = FLUID_BUTTON_PADDING_X[size];
    const py = FLUID_BUTTON_PADDING_Y[size];
    lines.push(`| ${size} | ${px[0]}→${px[1]}px | ${py[0]}→${py[1]}px |`);
  }
  lines.push('');

  // Input heights
  lines.push('### Fluid Input Heights');
  lines.push('');
  lines.push('| Size | CSS Variable | Min | Max |');
  lines.push('|---|---|---|---|');
  for (const [size, [min, max]] of Object.entries(FLUID_INPUT_HEIGHTS)) {
    lines.push(`| ${size} | \`--input-${size}-height\` | ${min}px | ${max}px |`);
  }
  lines.push('');

  return lines.join('\n');
}

function generateRadiusSection(): string {
  const lines: string[] = [];
  lines.push('## Border Radius');
  lines.push('');
  lines.push('| Scale | CSS Variable | Base (px) | Fluid Range |');
  lines.push('|---|---|---|---|');

  for (const [key, value] of Object.entries(tokens.radius)) {
    const fluid = FLUID_RADII[key];
    const range = fluid ? `${fluid[0]}px → ${fluid[1]}px` : 'Fixed';
    lines.push(`| ${key} | \`--radius-${key}\` | ${value}px | ${range} |`);
  }
  lines.push('');

  return lines.join('\n');
}

function generateAnimationSection(): string {
  const lines: string[] = [];
  const anim = tokens.animation;

  lines.push('## Animation');
  lines.push('');

  // Durations
  lines.push('### Durations');
  lines.push('');
  lines.push('| Name | CSS Variable | Value |');
  lines.push('|---|---|---|');
  for (const [key, value] of Object.entries(anim.duration)) {
    lines.push(`| ${key} | \`--duration-${key}\` | ${value}ms |`);
  }
  lines.push('');

  // Easings
  lines.push('### Easings');
  lines.push('');
  lines.push('| Name | CSS Variable | Value |');
  lines.push('|---|---|---|');
  for (const [key, value] of Object.entries(anim.easing)) {
    const cssKey = camelToKebab(key);
    lines.push(`| ${key} | \`--easing-${cssKey}\` | \`${value}\` |`);
  }
  lines.push('');

  return lines.join('\n');
}

// ============================================
// HELPERS
// ============================================

function camelToKebab(str: string): string {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/([a-zA-Z])(\d)/g, '$1-$2')
    .replace(/(\d)([a-zA-Z])/g, '$1-$2')
    .toLowerCase();
}
